import argparse

epilog = """Example:
 * With Windows

```
python ./myscript --help | Out-File -FilePath myscript_help.txt
python ./argparse_help_to_md myscript_help.txt Readme.md
```

 * With Linux
```
python myscript --help > myscript_help.txt
python argparse_help_to_md myscript_help.txt Readme.md
```
"""

parser = argparse.ArgumentParser(prog = "argparse_help_to_md", description = "Converts a help info to a standard documentation", epilog = epilog, 
                                 formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument("input", help = "Path to a text file containing the help generated by a Python script using argparse.")
parser.add_argument("output", help = "Output .md file", type = str)
parser.add_argument("--encoding", help = "Specify the encoding of the input file", type = str, default = "utf-8-sig")
parser.add_argument("--remove_arg_groups", 
                    help = "Remove the group titles (Positional/Optional arguments) for the arguments", 
                    action="store_true")
args = parser.parse_args()

input = open(args.input, 'r', encoding = args.encoding)
output = open(args.output, 'w')

lines = input.readlines()
usage_lines = []
description_lines = []
posArgsNames = []
optArgsNames = []
posArgsDesc = []
optArgsDesc = []
epilog_lines = []

typeline = "usage"
for line in lines:
    if typeline == "usage":
        if line[0:2] != "\n":
            usage_lines.append(line.replace("usage: ", ""))
        else:
            typeline = "description"
    elif typeline == "description":
        if line.startswith("positional arguments:"):
            typeline = "posArgs"
        elif line.startswith("optional arguments:"):
            typeline = "optArgs"
        else:
            description_lines.append(line)
    elif typeline in ["optArgs", "posArgs"]:
        if line.startswith("optional arguments:"):
            typeline = "optArgs"
        elif len(line.rstrip()) and line[0] != " ":
            typeline = "epilog" 
        else:
            if typeline == "posArgs":
                typArgNames, typArgDesc = posArgsNames,posArgsDesc
            else:
                typArgNames, typArgDesc = optArgsNames,optArgsDesc
            if len(line) > 1 and line[2] != " ": # the name of the argument is given here
                split = line.split("   ")
                typArgNames.append(split[0].strip())
                desc = ""
                # try find the description on the same line
                for i in range(1, len(split)):
                    if split[i].strip() != "":
                        desc += split[i].strip()
                typArgDesc.append(desc)
            elif len(line) > 1 and line[0:2] != "\n":
                # means that we are still describing the previous argument 
                typArgDesc[-1]+= line.strip()
                
    if typeline == "epilog":
        epilog_lines.append(line)


# Write in md file 
output.write("## Description\n")
for line in description_lines:
    output.write(line)
output.write("\n\n")

output.write("## Usage \n")
output.write("```bash\npython ")
for line in usage_lines:
    output.write(line)
output.write("```\n\n")


if posArgsNames or optArgsNames:
    output.write("## Arguments\n")
    if posArgsNames:
        if not(args.remove_arg_groups):
            output.write("**Positional arguments:**\n")
        for i in range(len(posArgsNames)):
            output.write(" * `{}`".format(posArgsNames[i]))
            if posArgsDesc[i] != "":
                output.write(" : {}".format(posArgsDesc[i]))
            output.write("\n")
        output.write("\n")
    
    if optArgsNames:
        if not(args.remove_arg_groups):
            output.write("**Optional arguments:**\n")
        for i in range(len(optArgsNames)):
            output.write(" * `{}`".format(optArgsNames[i]))
            if optArgsDesc[i] != "":
                output.write(" : {}".format(optArgsDesc[i]))
            output.write("\n")
        output.write("\n")

if epilog_lines: 
    output.write("## Other\n")
    for line in epilog_lines:
        output.write(line)    



input.close()
output.close()

